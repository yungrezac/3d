<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Такси — Telegram Mini App + Mapbox</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <!-- Telegram Mini Apps SDK -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <!-- Mapbox GL JS -->
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.css" rel="stylesheet" />
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.js"></script>
  <!-- Geocoder plugin -->
  <link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.1/mapbox-gl-geocoder.css" type="text/css" />
  <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.1/mapbox-gl-geocoder.min.js"></script>

  <style>
    :root {
      color-scheme: light;
      --bg: #ffffff;
      --text: #111827;
      --muted: #6b7280;
      --border: #e5e7eb;
      --elev: rgba(0,0,0,0.12);
      --primary: #111827;
      --chip: #eef2f7;
      --accent: #1e88e5;
      --danger: #ef4444;
      --success: #10b981;
      --hint: #9ca3af;
    }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body, #app { height: 100%; margin: 0; padding: 0; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      background: var(--bg); color: var(--text);
    }

    /* Карта */
    #map { position: absolute; inset: 0; }

    /* Верхняя панель */
    .topbar {
      position: fixed; left: 0; right: 0; top: 0; height: 52px; display: flex; align-items: center; justify-content: space-between;
      padding: 0 12px; z-index: 7; pointer-events: none;
    }
    .topbar > * { pointer-events: auto; }
    .user-pill {
      display:flex; align-items:center; gap:8px; background: rgba(255,255,255,0.9); border: 1px solid var(--border);
      border-radius: 999px; padding:6px 10px; box-shadow: 0 6px 20px var(--elev);
      backdrop-filter: saturate(120%) blur(6px);
    }
    .avatar {
      width: 24px; height: 24px; border-radius: 50%; background: var(--chip); display:grid; place-items:center; font-weight:700; font-size:12px;
    }

    /* Плавающие кнопки */
    .fabs { position: fixed; right: 16px; bottom: 120px; display: flex; flex-direction: column; gap: 12px; z-index: 8; }
    .fab {
      width: 44px; height: 44px; border-radius: 22px; display: grid; place-items: center;
      background: #fff; box-shadow: 0 6px 16px var(--elev); border: 1px solid var(--border); cursor: pointer;
    }
    .fab:active { transform: scale(0.98); }

    /* Нижняя плашка */
    .sheet {
      position: fixed; left: 0; right: 0; bottom: 0; z-index: 10;
      background: var(--bg);
      border-top-left-radius: 20px; border-top-right-radius: 20px;
      box-shadow: 0 -8px 30px var(--elev);
      max-height: 92vh;
      touch-action: none;
      transform: translateY(0); will-change: transform;
    }
    .sheet-grabber { height: 24px; display: grid; place-items: center; cursor: grab; }
    .sheet-grabber .bar { width: 44px; height: 5px; border-radius: 3px; background: #c7cad1; }
    .sheet-body { padding: 12px 16px 16px 16px; }

    .heading { font-size: 18px; font-weight: 600; margin: 6px 0 10px; }
    .muted { color: var(--muted); font-size: 13px; }
    .row { display: flex; align-items: center; gap: 10px; }
    .chips { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; }
    .chip {
      background: var(--chip); color: var(--text);
      padding: 6px 10px; border-radius: 14px; font-size: 13px; cursor: pointer; border: 1px solid var(--border);
      user-select: none;
    }
    .chip:active { transform: translateY(1px); }
    .chip.editable { position: relative; }
    .chip.editable::after { content: "⋯"; font-weight:700; margin-left:6px; color: var(--hint); }
    .divider { height: 1px; background: var(--border); margin: 12px 0; }

    .field {
      background: #f3f4f6; border-radius: 12px; padding: 10px 12px; border: 1px solid transparent;
      display: flex; align-items: center; gap: 8px;
    }
    .field.active { outline: 2px solid #dbeafe; border-color: #bfdbfe; background: #f8fbff; }
    .field .dot { width: 10px; height: 10px; border-radius: 50%; }
    .dot.pickup { background: var(--success); }
    .dot.dropoff { background: var(--danger); }

    .inline-btn {
      padding: 8px 10px; border-radius: 10px; border: 1px solid var(--border); background: #fff; font-size: 13px; cursor: pointer;
    }
    .cta {
      width: 100%; background: var(--primary); color: #fff; border: none; padding: 14px; border-radius: 12px; font-weight: 600; cursor: pointer;
    }
    .cta:disabled { opacity: 0.5; cursor: not-allowed; }
    .secondary {
      width: 100%; background: #f3f4f6; color: var(--text); border: none; padding: 12px; border-radius: 12px; font-weight: 500; cursor: pointer;
    }
    .list { display: grid; gap: 10px; }
    .tile {
      display: flex; align-items: center; justify-content: space-between; gap: 8px;
      padding: 12px; border: 1px solid var(--border); border-radius: 12px; background: #fff;
    }
    .price { font-weight: 700; }
    .badge { font-size: 12px; padding: 4px 8px; border-radius: 999px; background: #f3f4f6; border: 1px solid var(--border); cursor: pointer; }

    /* Overlay при full-режиме */
    .overlay {
      position: fixed; inset: 0; background: rgba(0,0,0,0.08); z-index: 9; opacity: 0; pointer-events: none; transition: opacity .2s ease;
    }
    .overlay.visible { opacity: 1; pointer-events: auto; }

    /* Geocoder контейнеры */
    .geocoder-wrap { display: grid; gap: 8px; }
    .geocoder { background: #fff; border-radius: 10px; border: 1px solid var(--border); overflow: hidden; }
    .mapboxgl-ctrl-geocoder { min-width: 100%; box-shadow: none; border-radius: 0; }
    .mapboxgl-ctrl-geocoder--input { font-size: 14px; }
    .mapboxgl-ctrl-geocoder--icon { margin: 0 6px; }

    /* Безопасные зоны */
    @supports (padding: env(safe-area-inset-bottom)) {
      .sheet-body { padding-bottom: calc(16px + env(safe-area-inset-bottom)); }
      .fabs { bottom: calc(120px + env(safe-area-inset-bottom)); }
      .topbar { padding-top: env(safe-area-inset-top); }
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="map"></div>

    <!-- Верхняя панель с пользователем -->
    <div class="topbar" id="topbar">
      <div class="user-pill" id="userPill" style="visibility:hidden;">
        <div class="avatar" id="userAvatar">U</div>
        <div id="userName" style="font-weight:600;">Пользователь</div>
      </div>
      <div></div>
    </div>

    <!-- overlay -->
    <div id="overlay" class="overlay"></div>

    <!-- Плавающие кнопки -->
    <div class="fabs">
      <button class="fab" id="btnRecenter" title="Моё местоположение">◎</button>
      <button class="fab" id="btnSwap" title="Поменять A/B">⇅</button>
      <button class="fab" id="btnClear" title="Сброс маршрута">×</button>
    </div>

    <!-- Нижняя плашка -->
    <div id="sheet" class="sheet">
      <div id="sheetGrabber" class="sheet-grabber"><div class="bar"></div></div>

      <div class="sheet-body">
        <!-- Collapsed -->
        <div id="panelIdle">
          <div class="field" id="fakeSearch">
            <div class="dot dropoff"></div>
            <div style="flex:1;">
              <div style="font-weight:600;">Куда едем?</div>
              <div class="muted">Нажмите, чтобы выбрать адрес</div>
            </div>
          </div>
          <div class="chips">
            <span class="chip editable" data-preset="home" id="chipHome">Дом</span>
            <span class="chip editable" data-preset="work" id="chipWork">Работа</span>
            <span class="chip" data-preset="recent" id="chipRecent">Недавние</span>
          </div>
        </div>

        <!-- Выбор адресов -->
        <div id="panelSelect" style="display:none;">
          <div class="heading">Куда поедем</div>

          <div class="geocoder-wrap">
            <div class="row" style="gap:8px;">
              <div class="field" id="pickupField" style="flex:1;">
                <div class="dot pickup"></div>
                <div style="flex:1;">
                  <div style="font-weight:600;" id="pickupLabel">Место посадки</div>
                  <div class="muted" id="pickupSub">Введите адрес или укажите на карте</div>
                </div>
              </div>
              <button id="pickupPointBtn" class="inline-btn">Указать</button>
              <button id="pickupMyBtn" class="inline-btn" title="Моё местоположение">Моё</button>
            </div>
            <div id="pickupGeocoder" class="geocoder"></div>

            <div class="row" style="gap:8px;">
              <div class="field" id="dropoffField" style="flex:1;">
                <div class="dot dropoff"></div>
                <div style="flex:1;">
                  <div style="font-weight:600;" id="dropoffLabel">Пункт назначения</div>
                  <div class="muted" id="dropoffSub">Введите адрес или укажите на карте</div>
                </div>
              </div>
              <button id="dropoffPointBtn" class="inline-btn">Указать</button>
            </div>
            <div id="dropoffGeocoder" class="geocoder"></div>
          </div>

          <div class="divider"></div>

          <div id="routeInfo" style="display:none;">
            <div class="row" style="justify-content: space-between;">
              <div>
                <div class="muted">Маршрут</div>
                <div><span id="distText">—</span> • <span id="etaText">—</span></div>
              </div>
              <span class="badge" id="payBadge">Оплата: Наличные</span>
            </div>

            <div class="list" style="margin-top:10px;">
              <div class="tile" id="tileEconomy">
                <div>
                  <div style="font-weight:600;">Эконом</div>
                  <div class="muted">Быстро и выгодно</div>
                </div>
                <div class="price" id="priceEconomy">—</div>
              </div>

              <div class="tile" id="tileComfort">
                <div>
                  <div style="font-weight:600;">Комфорт</div>
                  <div class="muted">Больше места</div>
                </div>
                <div class="price" id="priceComfort">—</div>
              </div>
            </div>

            <!-- Fallback CTA вне Telegram -->
            <button id="btnOrder" class="cta" style="margin-top:12px; display:none;">Заказать</button>
          </div>
        </div>

        <!-- Ожидание/Поездка/Завершение -->
        <div id="panelRide" style="display:none;">
          <div id="rideStateWaiting">
            <div class="heading">Ищем водителя…</div>
            <div class="muted">Обычно это занимает ~2 минуты</div>
            <button id="btnCancelSearch" class="secondary" style="margin-top:12px;">Отмена</button>
          </div>

          <div id="rideStateEnRoute" style="display:none;">
            <div class="heading">В пути</div>
            <div class="muted">Прибытие: <span id="arriveTime">—:—</span></div>
            <div class="chips" style="margin-top:10px;">
              <span class="chip" id="chipShare">Поделиться поездкой</span>
              <span class="chip" id="chipSafety">Безопасность</span>
            </div>
            <button id="btnFinish" class="secondary" style="margin-top:12px;">Завершить поездку (демо)</button>
          </div>

          <div id="rideStateCompleted" style="display:none;">
            <div class="heading">Поездка завершена</div>
            <div class="muted" id="fareSummary">Спасибо, что выбрали нас</div>
            <button id="btnDone" class="cta" style="margin-top:12px;">Готово</button>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // =============== Конфиг ===============
  // Установите ваш Mapbox токен: можно в window.MAPBOX_TOKEN, через ?mb=... или ниже в константу.
  const MAPBOX_TOKEN = (window.MAPBOX_TOKEN || new URLSearchParams(location.search).get('mb') || 'pk.eyJ1IjoieXVuZ3JlemFjIiwiYSI6ImNtOW10ZzJ6bDBjNHUyanI3ejc5eXo1d2MifQ._tryk9cXjfReUGLGnNkm6Q').trim();
  const DEFAULT_CENTER = [37.618423, 55.751244]; // Москва [lng, lat]
  const TG = window.Telegram && window.Telegram.WebApp ? window.Telegram.WebApp : null;

  if (!MAPBOX_TOKEN || MAPBOX_TOKEN === 'REPLACE_WITH_YOUR_MAPBOX_TOKEN') {
    console.warn('Mapbox token не задан. Передайте его через window.MAPBOX_TOKEN, ?mb=TOKEN или в коде.');
  }
  mapboxgl.accessToken = MAPBOX_TOKEN;

  // =============== Тема/Telegram интеграция ===============
  function parseHexColor(hex) {
    if (!hex || typeof hex !== 'string') return null;
    const m = hex.replace('#','').match(/^([0-9a-f]{6}|[0-9a-f]{8})$/i);
    if (!m) return null;
    const v = m[1];
    const r = parseInt(v.slice(0,2), 16);
    const g = parseInt(v.slice(2,4), 16);
    const b = parseInt(v.slice(4,6), 16);
    return { r, g, b };
  }
  function isDarkFromColor(hex) {
    const c = parseHexColor(hex);
    if (!c) return false;
    // относительная яркость
    const y = 0.2126*(c.r/255)**2.2 + 0.7152*(c.g/255)**2.2 + 0.0722*(c.b/255)**2.2;
    return y < 0.5;
  }
  function getMapStyleForTheme(tp) {
    const dark = tp ? isDarkFromColor(tp.bg_color) : false;
    return dark ? 'mapbox://styles/mapbox/dark-v11' : 'mapbox://styles/mapbox/streets-v12';
  }
  function applyThemeFromTelegram() {
    if (!TG) return;
    const tp = TG.themeParams || {};
    const r = document.documentElement.style;

    if (tp.bg_color) r.setProperty('--bg', tp.bg_color);
    if (tp.text_color) r.setProperty('--text', tp.text_color);
    if (tp.hint_color) r.setProperty('--muted', tp.hint_color);
    if (tp.secondary_bg_color) r.setProperty('--chip', tp.secondary_bg_color);
    if (tp.link_color) r.setProperty('--accent', tp.link_color);
    if (tp.button_color) r.setProperty('--primary', tp.button_color);

    TG.setHeaderColor(tp.bg_color || '#ffffff');
    TG.setBackgroundColor(tp.bg_color || '#ffffff');

    // Переключение стиля карты
    try {
      const style = getMapStyleForTheme(tp);
      if (map && style && map.getStyle()?.sprite?.indexOf(style) === -1) {
        map.setStyle(style);
        map.once('styledata', () => ensureSourcesLayers()); // восстановить слои
      }
    } catch {}
  }
  function initTelegram() {
    if (!TG) {
      document.getElementById('btnOrder').style.display = ''; // fallback кнопка
      return;
    }
    TG.ready();
    TG.expand();
    applyThemeFromTelegram();
    TG.onEvent('themeChanged', applyThemeFromTelegram);

    // User pill
    const user = (TG.initDataUnsafe || {}).user;
    if (user) {
      const pill = document.getElementById('userPill');
      const name = [user.first_name, user.last_name].filter(Boolean).join(' ') || 'Пользователь';
      document.getElementById('userName').textContent = name;
      document.getElementById('userAvatar').textContent = (user.first_name || 'U').slice(0,1).toUpperCase();
      pill.style.visibility = 'visible';
    }

    // MainButton
    TG.MainButton.setParams({
      text: 'Заказать',
      is_active: false,
      is_visible: true,
      color: getComputedStyle(document.documentElement).getPropertyValue('--primary').trim()
    });
    TG.onEvent('mainButtonClicked', () => handleOrderClick());

    // BackButton
    TG.BackButton.onClick(() => {
      if (state.ridePhase === 'selecting') {
        setRidePhase('idle'); snapTo('collapsed');
      } else if (state.ridePhase === 'waiting' || state.ridePhase === 'enRoute') {
        TG.showConfirm('Отменить поездку?', (ok) => {
          if (ok) {
            stopRouteSimulation();
            setRidePhase('selecting'); snapTo('half');
            TG.HapticFeedback.notificationOccurred('warning');
          }
        });
      } else if (state.ridePhase === 'completed') {
        setRidePhase('idle'); snapTo('collapsed');
      } else {
        TG.close();
      }
    });
    updateBackButton();
  }
  function updateMainButton() {
    if (!TG) return;
    const canOrder = !!(state.route && state.pickup && state.dropoff);
    TG.MainButton.setParams({ is_active: canOrder, is_visible: true, text: 'Заказать' });
  }
  function updateBackButton() {
    if (!TG) return;
    const needsBack = state.ridePhase !== 'idle';
    if (needsBack) TG.BackButton.show(); else TG.BackButton.hide();
  }

  // =============== Состояние/DOM ===============
  const state = {
    sheet: { detent: 'collapsed' }, // collapsed | half | full
    activePickByMap: null,          // 'pickup' | 'dropoff' | null
    pickup: null,                   // { lng, lat, placeName }
    dropoff: null,
    route: null,                    // Feature LineString
    routeSummary: null,             // { distanceKm, durationMin }
    ridePhase: 'idle',              // idle | selecting | waiting | enRoute | completed
    selectedTariff: 'economy',      // economy | comfort
    payment: 'cash',                // cash | card
    presets: { home: null, work: null }, // {lng,lat,placeName}
    recent: [],                     // [{lng,lat,placeName,ts}, ...]
    sim: { timer: null, idx: 0, coords: [], startTime: 0, durationSec: 0 },
    controllers: { routeAbort: null }
  };

  const el = {
    sheet: document.getElementById('sheet'),
    grab: document.getElementById('sheetGrabber'),
    overlay: document.getElementById('overlay'),
    panelIdle: document.getElementById('panelIdle'),
    panelSelect: document.getElementById('panelSelect'),
    panelRide: document.getElementById('panelRide'),
    fakeSearch: document.getElementById('fakeSearch'),
    pickupField: document.getElementById('pickupField'),
    dropoffField: document.getElementById('dropoffField'),
    pickupLabel: document.getElementById('pickupLabel'),
    pickupSub: document.getElementById('pickupSub'),
    dropoffLabel: document.getElementById('dropoffLabel'),
    dropoffSub: document.getElementById('dropoffSub'),
    btnPickupPoint: document.getElementById('pickupPointBtn'),
    btnDropoffPoint: document.getElementById('dropoffPointBtn'),
    btnPickupMy: document.getElementById('pickupMyBtn'),
    routeInfo: document.getElementById('routeInfo'),
    distText: document.getElementById('distText'),
    etaText: document.getElementById('etaText'),
    priceEconomy: document.getElementById('priceEconomy'),
    priceComfort: document.getElementById('priceComfort'),
    tileEconomy: document.getElementById('tileEconomy'),
    tileComfort: document.getElementById('tileComfort'),
    btnOrder: document.getElementById('btnOrder'),
    btnRecenter: document.getElementById('btnRecenter'),
    btnSwap: document.getElementById('btnSwap'),
    btnClear: document.getElementById('btnClear'),
    rideWaiting: document.getElementById('rideStateWaiting'),
    rideEnRoute: document.getElementById('rideStateEnRoute'),
    rideCompleted: document.getElementById('rideStateCompleted'),
    btnCancelSearch: document.getElementById('btnCancelSearch'),
    btnFinish: document.getElementById('btnFinish'),
    btnDone: document.getElementById('btnDone'),
    arriveTime: document.getElementById('arriveTime'),
    fareSummary: document.getElementById('fareSummary'),
    chipHome: document.getElementById('chipHome'),
    chipWork: document.getElementById('chipWork'),
    chipRecent: document.getElementById('chipRecent'),
    topbar: document.getElementById('topbar'),
    payBadge: document.getElementById('payBadge')
  };

  // =============== Карта ===============
  const map = new mapboxgl.Map({
    container: 'map',
    style: getMapStyleForTheme((TG && TG.themeParams) || null),
    center: DEFAULT_CENTER,
    zoom: 12,
    attributionControl: false,
    cooperativeGestures: true,
    locale: 'ru',
  });
  map.addControl(new mapboxgl.AttributionControl({ compact: true }));
  map.addControl(new mapboxgl.NavigationControl({ visualizePitch: true }), 'top-right');
  const geolocateCtrl = new mapboxgl.GeolocateControl({ positionOptions: { enableHighAccuracy: true }, trackUserLocation: true, showUserHeading: true });
  map.addControl(geolocateCtrl, 'top-right');

  function ensureSourcesLayers() {
    if (!map.getSource('route')) {
      map.addSource('route', { type: 'geojson', data: { type: 'FeatureCollection', features: [] }});
      map.addLayer({
        id: 'route-line',
        type: 'line',
        source: 'route',
        layout: { 'line-join': 'round', 'line-cap': 'round' },
        paint: { 'line-color': '#1E88E5', 'line-width': 5, 'line-opacity': 0.9 }
      });
    } else {
      // Перезалить текущий маршрут после смены стиля
      try {
        const fc = state.route ? { type:'FeatureCollection', features:[state.route] } : { type:'FeatureCollection', features:[] };
        map.getSource('route').setData(fc);
      } catch {}
    }
  }
  map.on('load', () => {
    ensureSourcesLayers();
    // Попробуем установить точку посадки из геолокации при первом запуске
    if (!state.pickup) tryPrefillPickupFromGeolocation();
  });

  // Маркеры
  const pickupMarker = new mapboxgl.Marker({ color: '#10b981' });
  const dropoffMarker = new mapboxgl.Marker({ color: '#ef4444' });
  const carMarker = new mapboxgl.Marker({ color: '#111827' });

  // Geocoder
  const pickupGeocoder = new MapboxGeocoder({
    accessToken: MAPBOX_TOKEN,
    mapboxgl, placeholder: 'Место посадки', marker: false, language: 'ru-RU',
    proximity: { longitude: DEFAULT_CENTER[0], latitude: DEFAULT_CENTER[1] },
    types: 'address,poi,place,locality,neighborhood'
  });
  pickupGeocoder.addTo('#pickupGeocoder');

  const dropoffGeocoder = new MapboxGeocoder({
    accessToken: MAPBOX_TOKEN,
    mapboxgl, placeholder: 'Пункт назначения', marker: false, language: 'ru-RU',
    proximity: { longitude: DEFAULT_CENTER[0], latitude: DEFAULT_CENTER[1] },
    types: 'address,poi,place,locality,neighborhood'
  });
  dropoffGeocoder.addTo('#dropoffGeocoder');

  pickupGeocoder.on('result', (e) => setPoint('pickup', e.result));
  dropoffGeocoder.on('result', (e) => setPoint('dropoff', e.result));

  map.on('click', (ev) => {
    if (!state.activePickByMap) return;
    const lngLat = ev.lngLat.wrap();
    setPoint(state.activePickByMap, {
      center: [lngLat.lng, lngLat.lat],
      place_name: `Точка на карте (${lngLat.lat.toFixed(5)}, ${lngLat.lng.toFixed(5)})`
    });
    setActivePickByMap(null);
  });

  // =============== Логика UI ===============
  const detents = {
    collapsed: () => 96,
    half: () => Math.round(window.innerHeight * 0.56),
    full: () => Math.round(Math.min(window.innerHeight * 0.9, window.innerHeight - 24))
  };
  let dragging = false, startY = 0, startH = 0;
  function currentHeight() {
    const rect = el.sheet.getBoundingClientRect();
    return Math.round(window.innerHeight - rect.top);
  }
  function applyHeight(h, { animate=true } = {}) {
    const clamped = Math.max(80, Math.min(detents.full(), h));
    if (animate) el.sheet.style.transition = 'transform .18s ease';
    const ty = window.innerHeight - clamped;
    el.sheet.style.transform = `translateY(${ty}px)`;
    const fullH = detents.full();
    const ratio = Math.min(1, Math.max(0, (clamped - detents.half()) / (fullH - detents.half())));
    el.overlay.classList.toggle('visible', ratio > 0.02);
    setMapPadding(clamped);
    setTimeout(() => { el.sheet.style.transition = ''; }, 200);
  }
  function snapTo(target) {
    state.sheet.detent = target;
    applyHeight(detents[target](), { animate:true });
    if (TG && target) TG.HapticFeedback.impactOccurred(target === 'full' ? 'heavy' : target === 'half' ? 'medium' : 'light');
  }
  function snapToNearest(h) {
    const options = ['collapsed','half','full'];
    let best = 'collapsed', bestDiff = Infinity;
    for (const key of options) {
      const dh = Math.abs(detents[key]() - h);
      if (dh < bestDiff) { best = key; bestDiff = dh; }
    }
    snapTo(best);
  }
  function setMapPadding(sheetHeight) {
    const padding = { top: 60, right: 16, bottom: Math.min(sheetHeight + 20, Math.round(window.innerHeight * 0.7)), left: 16 };
    const center = map.getCenter();
    map.easeTo({ center, padding, duration: 250 });
  }
  function onResize() { applyHeight(detents[state.sheet.detent](), { animate:false }); }
  window.addEventListener('resize', onResize);

  el.grab.addEventListener('pointerdown', (e) => {
    dragging = true; startY = e.clientY; startH = currentHeight();
    el.grab.setPointerCapture(e.pointerId);
    el.grab.style.cursor = 'grabbing';
  });
  el.grab.addEventListener('pointermove', (e) => {
    if (!dragging) return;
    const dy = startY - e.clientY;
    applyHeight(startH + dy, { animate:false });
  });
  const endDrag = (e) => {
    if (!dragging) return;
    dragging = false;
    el.grab.releasePointerCapture(e.pointerId);
    el.grab.style.cursor = 'grab';
    snapToNearest(currentHeight());
  };
  el.grab.addEventListener('pointerup', endDrag);
  el.grab.addEventListener('pointercancel', endDrag);
  snapTo('collapsed');

  // События UI
  el.fakeSearch.addEventListener('click', () => { setRidePhase('selecting'); snapTo('full'); });
  el.pickupField.addEventListener('click', () => { setRidePhase('selecting'); snapTo('full'); });
  el.dropoffField.addEventListener('click', () => { setRidePhase('selecting'); snapTo('full'); });
  el.btnPickupPoint.addEventListener('click', () => setActivePickByMap(state.activePickByMap === 'pickup' ? null : 'pickup'));
  el.btnDropoffPoint.addEventListener('click', () => setActivePickByMap(state.activePickByMap === 'dropoff' ? null : 'dropoff'));
  el.btnPickupMy.addEventListener('click', () => setPickupToMyLocation());
  el.btnRecenter.addEventListener('click', () => { try { geolocateCtrl.trigger(); } catch { map.easeTo({ center: DEFAULT_CENTER, zoom: 12 }); } });
  el.btnSwap.addEventListener('click', swapPoints);
  el.btnClear.addEventListener('click', clearAll);

  // Тарифы
  el.tileEconomy.addEventListener('click', () => { state.selectedTariff = 'economy'; highlightTariff(); TG && TG.HapticFeedback.selectionChanged(); });
  el.tileComfort.addEventListener('click', () => { state.selectedTariff = 'comfort'; highlightTariff(); TG && TG.HapticFeedback.selectionChanged(); });
  function highlightTariff() {
    const accent = getComputedStyle(document.documentElement).getPropertyValue('--accent');
    const border = getComputedStyle(document.documentElement).getPropertyValue('--border');
    el.tileEconomy.style.borderColor = state.selectedTariff === 'economy' ? accent : border;
    el.tileComfort.style.borderColor = state.selectedTariff === 'comfort' ? accent : border;
  }

  // Оплата (переключатель)
  el.payBadge.addEventListener('click', async () => {
    const next = state.payment === 'cash' ? 'card' : 'cash';
    state.payment = next;
    updatePaymentBadge();
    saveCloudStorage('payment', state.payment);
    TG && TG.HapticFeedback.selectionChanged();
  });
  function updatePaymentBadge() {
    el.payBadge.textContent = 'Оплата: ' + (state.payment === 'cash' ? 'Наличные' : 'Карта');
  }

  // Fallback кнопка «Заказать» без Telegram
  el.btnOrder.addEventListener('click', () => handleOrderClick());

  // Ожидание/поездка/завершение
  el.btnCancelSearch.addEventListener('click', () => {
    if (TG) {
      TG.showConfirm('Отменить поиск водителя?', (ok) => { if (ok) { setRidePhase('selecting'); snapTo('half'); stopRouteSimulation(); }});
    } else {
      setRidePhase('selecting'); snapTo('half'); stopRouteSimulation();
    }
  });
  el.btnFinish.addEventListener('click', () => { setRidePhase('completed'); snapTo('full'); stopRouteSimulation(); });
  el.btnDone.addEventListener('click', () => {
    clearAll();
    setRidePhase('idle'); snapTo('collapsed');
    if (TG) TG.close();
  });

  // Share / Safety
  document.getElementById('chipShare').addEventListener('click', () => {
    const text = `Еду на такси: ${state.pickup?.placeName || '—'} → ${state.dropoff?.placeName || '—'} • прибытие ${el.arriveTime.textContent}`;
    const url = 'https://t.me/share/url?text=' + encodeURIComponent(text);
    if (TG) TG.openTelegramLink(url); else window.open(url, '_blank');
  });
  document.getElementById('chipSafety').addEventListener('click', () => {
    const message = 'В экстренной ситуации звоните 112.\nСлужба поддержки: @support';
    if (TG) TG.showPopup({ title: 'Безопасность', message, buttons: [{type:'ok'}] });
    else alert(message);
  });

  // Дом/Работа/Недавние
  el.chipHome.addEventListener('click', () => handlePreset('home'));
  el.chipWork.addEventListener('click', () => handlePreset('work'));
  el.chipRecent.addEventListener('click', () => showRecent());

  // =============== CloudStorage / LocalStorage ===============
  async function loadCloudStorage() {
    const applyLoaded = (data) => {
      try {
        state.presets.home = data.preset_home ? JSON.parse(data.preset_home) : null;
        state.presets.work = data.preset_work ? JSON.parse(data.preset_work) : null;
        state.recent = data.recent ? JSON.parse(data.recent) : [];
        state.payment = data.payment ? JSON.parse(data.payment) : (state.payment || 'cash');
        updatePaymentBadge();
      } catch {}
    };
    if (!TG) {
      try {
        applyLoaded({
          preset_home: localStorage.getItem('preset_home'),
          preset_work: localStorage.getItem('preset_work'),
          recent: localStorage.getItem('recent'),
          payment: localStorage.getItem('payment'),
        });
      } catch {}
      return;
    }
    TG.CloudStorage.getItems(['preset_home','preset_work','recent','payment'], (err, data) => {
      if (err) return;
      applyLoaded(data || {});
    });
  }
  function saveCloudStorage(key, value) {
    const str = JSON.stringify(value);
    if (TG) {
      TG.CloudStorage.setItem(key, str, () => {});
    } else {
      localStorage.setItem(key, str);
    }
  }
  async function handlePreset(kind) {
    const preset = state.presets[kind];
    if (preset) {
      setRidePhase('selecting'); snapTo('half');
      setPoint('dropoff', { center: [preset.lng, preset.lat], place_name: preset.placeName || (kind === 'home' ? 'Дом' : 'Работа') });
      return;
    }
    const ask = (message, cb) => TG ? TG.showConfirm(message, (ok) => cb(ok)) : cb(confirm(message));
    ask(`Сохранить текущее местоположение как «${kind === 'home' ? 'Дом' : 'Работа'}»?`, async (ok) => {
      if (!ok) return;
      try {
        const pos = await getCurrentPosition();
        const lng = pos.coords.longitude, lat = pos.coords.latitude;
        const placeName = await reverseGeocode(lng, lat);
        const entry = { lng, lat, placeName };
        state.presets[kind] = entry;
        saveCloudStorage('preset_' + kind, entry);
        toast('Сохранено');
      } catch {
        toast('Не удалось получить геопозицию');
      }
    });
  }
  function showRecent() {
    if (!state.recent.length) {
      toast('Недавних адресов пока нет'); return;
    }
    const items = state.recent.slice().reverse().slice(0, 5).map((r,i) => `${i+1}. ${r.placeName}`).join('\n');
    if (TG) TG.showPopup({ title: 'Недавние', message: items, buttons: [{type:'ok'}] });
    else alert('Недавние:\n' + items);
  }

  // =============== Геокодинг/Маршруты ===============
  async function reverseGeocode(lng, lat) {
    const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${lng},${lat}.json?language=ru&access_token=${encodeURIComponent(MAPBOX_TOKEN)}`;
    const resp = await fetch(url);
    const data = await resp.json();
    return data.features?.[0]?.place_name || `Точка (${lat.toFixed(5)}, ${lng.toFixed(5)})`;
  }
  function setActivePickByMap(kind) {
    state.activePickByMap = kind;
    el.pickupField.classList.toggle('active', kind === 'pickup');
    el.dropoffField.classList.toggle('active', kind === 'dropoff');
    el.btnPickupPoint.textContent = (kind === 'pickup') ? 'Готово' : 'Указать';
    el.btnDropoffPoint.textContent = (kind === 'dropoff') ? 'Готово' : 'Указать';
    if (kind) snapTo('half');
  }
  function setRidePhase(phase) {
    state.ridePhase = phase;
    el.panelIdle.style.display = (phase === 'idle') ? '' : 'none';
    el.panelSelect.style.display = (phase === 'selecting') ? '' : 'none';
    el.panelRide.style.display = (phase === 'waiting' || phase === 'enRoute' || phase === 'completed') ? '' : 'none';
    el.rideWaiting.style.display = (phase === 'waiting') ? '' : 'none';
    el.rideEnRoute.style.display = (phase === 'enRoute') ? '' : 'none';
    el.rideCompleted.style.display = (phase === 'completed') ? '' : 'none';
    updateBackButton();
    updateMainButton();
  }
  function setPoint(kind, result) {
    const coord = result.center || (result.geometry && result.geometry.coordinates);
    if (!coord) return;
    const [lng, lat] = coord;
    const placeName = result.place_name || result.text || 'Точка';
    if (kind === 'pickup') {
      state.pickup = { lng, lat, placeName };
      pickupMarker.setLngLat([lng, lat]).addTo(map);
      el.pickupLabel.textContent = 'Посадка';
      el.pickupSub.textContent = placeName;
      dropoffGeocoder.setProximity({ longitude: lng, latitude: lat });
      if (!state.dropoff) map.easeTo({ center: [lng, lat], zoom: Math.max(map.getZoom(), 13) });
    } else {
      state.dropoff = { lng, lat, placeName };
      dropoffMarker.setLngLat([lng, lat]).addTo(map);
      el.dropoffLabel.textContent = 'Назначение';
      el.dropoffSub.textContent = placeName;
    }
    if (TG) TG.HapticFeedback.selectionChanged();
    if (state.pickup && state.dropoff) buildRoute();
    updateMainButton();
  }
  function swapPoints() {
    if (!(state.pickup && state.dropoff)) return;
    const a = state.pickup, b = state.dropoff;
    state.pickup = b; state.dropoff = a;
    pickupMarker.setLngLat([state.pickup.lng, state.pickup.lat]).addTo(map);
    dropoffMarker.setLngLat([state.dropoff.lng, state.dropoff.lat]).addTo(map);
    el.pickupSub.textContent = state.pickup.placeName;
    el.dropoffSub.textContent = state.dropoff.placeName;
    buildRoute();
  }

  async function buildRoute() {
    const a = state.pickup, b = state.dropoff;
    if (!a || !b) return;

    // отмена предыдущего запроса
    if (state.controllers.routeAbort) state.controllers.routeAbort.abort();
    const ctrl = new AbortController();
    state.controllers.routeAbort = ctrl;

    try {
      const url = new URL(`https://api.mapbox.com/directions/v5/mapbox/driving/${a.lng},${a.lat};${b.lng},${b.lat}`);
      url.searchParams.set('geometries', 'geojson');
      url.searchParams.set('overview', 'full');
      url.searchParams.set('language', 'ru');
      url.searchParams.set('access_token', MAPBOX_TOKEN);
      // можно включить пробки: url.searchParams.set('annotations','congestion');

      const resp = await fetch(url.toString(), { signal: ctrl.signal });
      if (!resp.ok) throw new Error('Ошибка сети');
      const data = await resp.json();
      if (!data.routes || !data.routes[0]) throw new Error('Маршрут не найден');

      const route = data.routes[0];
      const line = route.geometry;
      state.route = { type: 'Feature', geometry: line, properties: {} };

      const fc = { type: 'FeatureCollection', features: [state.route] };
      map.getSource('route').setData(fc);

      const distanceKm = route.distance / 1000;
      const durationMin = route.duration / 60;
      state.routeSummary = { distanceKm, durationMin };

      el.distText.textContent = `${distanceKm.toFixed(1)} км`;
      el.etaText.textContent = `~${Math.round(durationMin)} мин`;

      const { economy, comfort } = estimatePrices(distanceKm, durationMin);
      el.priceEconomy.textContent = `~${economy} ₽`;
      el.priceComfort.textContent = `~${comfort} ₽`;

      el.routeInfo.style.display = '';
      highlightTariff();

      // fit bounds
      const bounds = line.coordinates.reduce((b, c) => b.extend(c), new mapboxgl.LngLatBounds(line.coordinates[0], line.coordinates[0]));
      map.fitBounds(bounds, { padding: { top: 80, right: 40, bottom: currentHeight() + 40, left: 40 }, duration: 500 });

      setRidePhase('selecting');
      snapTo('half');
      updateMainButton();
      pushRecent(state.dropoff);
    } catch (err) {
      if (err?.name === 'AbortError') return; // отменено — тихо
      console.error(err);
      toast('Не удалось построить маршрут');
      TG && TG.HapticFeedback.notificationOccurred('error');
    } finally {
      state.controllers.routeAbort = null;
    }
  }

  function estimatePrices(km, min) {
    // Простая модель: посадка + км + мин (Москву возьмём условно)
    const economyBase = 60, economyPerKm = 16, economyPerMin = 4, economyMinFare = 99;
    const comfortBase = 80, comfortPerKm = 22, comfortPerMin = 6, comfortMinFare = 149;

    const econ = Math.max(economyMinFare, economyBase + economyPerKm * km + economyPerMin * min);
    const conf = Math.max(comfortMinFare, comfortBase + comfortPerKm * km + comfortPerMin * min);
    return { economy: Math.round(econ), comfort: Math.round(conf) };
  }

  function clearAll() {
    stopRouteSimulation();
    state.pickup = null; state.dropoff = null; state.route = null; state.routeSummary = null;

    try { map.getSource('route').setData({ type:'FeatureCollection', features:[] }); } catch {}
    pickupMarker.remove(); dropoffMarker.remove(); carMarker.remove();

    el.pickupLabel.textContent = 'Место посадки';
    el.pickupSub.textContent = 'Введите адрес или укажите на карте';
    el.dropoffLabel.textContent = 'Пункт назначения';
    el.dropoffSub.textContent = 'Введите адрес или укажите на карте';

    el.routeInfo.style.display = 'none';
    pickupGeocoder.clear(); dropoffGeocoder.clear();

    state.selectedTariff = 'economy'; highlightTariff();
    updateMainButton();
  }

  function pushRecent(place) {
    if (!place) return;
    const rec = { lng: place.lng, lat: place.lat, placeName: place.placeName, ts: Date.now() };
    state.recent = state.recent.filter(r => Math.abs(r.lng - rec.lng) > 1e-6 || Math.abs(r.lat - rec.lat) > 1e-6);
    state.recent.push(rec);
    state.recent = state.recent.slice(-10);
    saveCloudStorage('recent', state.recent);
  }

  // =============== Заказ (Telegram MainButton) ===============
  async function handleOrderClick() {
    if (!(state.pickup && state.dropoff && state.routeSummary)) return;
    setRidePhase('waiting'); snapTo('half');
    TG && TG.HapticFeedback.notificationOccurred('success');

    const order = {
      type: 'ride_order',
      tariff: state.selectedTariff,
      payment: state.payment, // cash | card
      pickup: state.pickup,
      dropoff: state.dropoff,
      distance_km: Number(state.routeSummary.distanceKm.toFixed(2)),
      duration_min: Math.round(state.routeSummary.durationMin),
      client_ts: Date.now()
    };

    if (TG) {
      try { TG.sendData(JSON.stringify(order)); } catch {}
    } else {
      console.log('Order:', order);
    }

    // Имитируем назначение водителя
    setTimeout(() => {
      setRidePhase('enRoute'); snapTo('half');
      startRouteSimulation();
    }, 1200);
  }

  // =============== Симуляция поездки (демо) ===============
  function startRouteSimulation() {
    stopRouteSimulation();
    if (!state.route) return;
    const coords = state.route.geometry.coordinates.slice();
    if (!coords.length) return;

    state.sim.coords = coords;
    state.sim.idx = 0;

    const durationSec = Math.max(60, Math.round((state.routeSummary?.durationMin || 10) * 60));
    state.sim.durationSec = durationSec;
    state.sim.startTime = Date.now();

    carMarker.setLngLat(coords[0]).addTo(map);

    state.sim.timer = setInterval(() => {
      const t = Math.min(1, (Date.now() - state.sim.startTime) / (durationSec * 1000));
      const idx = Math.floor(t * (coords.length - 1));
      state.sim.idx = idx;
      const cur = coords[idx];
      carMarker.setLngLat(cur);

      // ETA
      const remainingSec = Math.max(0, durationSec - (Date.now() - state.sim.startTime)/1000);
      const arrive = new Date(Date.now() + remainingSec * 1000);
      el.arriveTime.textContent = `${String(arrive.getHours()).padStart(2,'0')}:${String(arrive.getMinutes()).padStart(2,'0')}`;

      if (t >= 1) {
        stopRouteSimulation();
        setRidePhase('completed'); snapTo('full');
        const price = state.selectedTariff === 'economy' ? el.priceEconomy.textContent : el.priceComfort.textContent;
        const payText = state.payment === 'cash' ? 'Наличные' : 'Карта';
        el.fareSummary.textContent = `Сумма: ${price} • Оплата: ${payText}`;
        TG && TG.HapticFeedback.notificationOccurred('success');
      }
    }, 700);
  }
  function stopRouteSimulation() {
    if (state.sim.timer) clearInterval(state.sim.timer);
    state.sim.timer = null;
  }

  // =============== Вспомогательные ===============
  function toast(msg) {
    if (TG && TG.showPopup) {
      TG.showPopup({ title: 'Сообщение', message: msg, buttons: [{type:'ok'}] });
    } else {
      alert(msg);
    }
  }
  function getCurrentPosition() {
    return new Promise((resolve, reject) => {
      if (!navigator.geolocation) return reject(new Error('geolocation unavailable'));
      navigator.geolocation.getCurrentPosition(resolve, reject, { enableHighAccuracy: true, timeout: 10000 });
    });
  }
  async function setPickupToMyLocation() {
    try {
      const pos = await getCurrentPosition();
      const lng = pos.coords.longitude, lat = pos.coords.latitude;
      const name = await reverseGeocode(lng, lat);
      setPoint('pickup', { center: [lng, lat], place_name: name });
      map.easeTo({ center: [lng, lat], zoom: Math.max(map.getZoom(), 14) });
    } catch {
      toast('Не удалось получить геопозицию');
    }
  }
  function tryPrefillPickupFromGeolocation() {
    // Ненавязчиво просим геолокацию для удобства
    setTimeout(async () => {
      try {
        const pos = await getCurrentPosition();
        const lng = pos.coords.longitude, lat = pos.coords.latitude;
        const name = await reverseGeocode(lng, lat);
        setPoint('pickup', { center: [lng, lat], place_name: name });
      } catch {}
    }, 400);
  }

  // =============== Инициализация ===============
  initTelegram();
  loadCloudStorage();
  setRidePhase('idle');
  updatePaymentBadge();
  document.addEventListener('visibilitychange', updateMainButton);
})();
</script>
</body>
</html>
